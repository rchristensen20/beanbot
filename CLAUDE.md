# CLAUDE.md

## Project Overview

Beanbot is a personal gardening assistant Discord bot. It uses a LangGraph agentic workflow backed by the Google Gemini API to manage a markdown-based knowledge library, task list, harvest log, and garden journal.

## Tech Stack

- **Python 3.13** with discord.py, LangGraph, langchain-google-genai, pymupdf
- **Google Gemini API** (Gemini 2.5 Flash) for LLM inference
- **LangGraph** state machine with tool-calling loop and SQLite checkpointer for conversation memory
- **Docker** for deployment (single container, `docker-compose up`)

## Architecture

```
src/bot.py                      → Discord bot: message routing, commands, scheduled crons, UI components
src/graph.py                    → LangGraph state machine: agent node ↔ tool node loop, system prompt, checkpointer
src/services/tools.py           → Pure functions: file I/O, task management, harvest logging, calendar generation, member registry, web search
src/services/weather.py         → Standalone async weather/forecast fetchers (OpenWeatherMap API)
src/services/categorization.py  → LLM-based file categorization and merge suggestion (used by !consolidate)
data/                           → Markdown knowledge library (auto-managed by the bot)
```

### Key patterns

- **Channel-based routing** — `on_message` checks channel ID to determine context (journal, questions, knowledge_ingest, DM). Context strings are defined in the `CHANNEL_CONTEXT` dict at the top of `bot.py` and prepended to the HumanMessage, not stored as a separate SystemMessage.
- **PDF ingestion** — PDF attachments in the knowledge_ingest channel are detected by content type or `.pdf` extension, text-extracted via `pymupdf`, and fed into the same ingestion pipeline as URL/text content. Scanned PDFs without a text layer will yield empty results (no OCR).
- **LLM processes everything** — Rather than rigid parsing, structured user input (like debrief forms) is sent as a prompt to the LangGraph agent. The agent decides which tools to call.
- **Persistent Discord views** — `discord.ui.View(timeout=None)` with `custom_id` on buttons, registered in `setup_hook` via `self.add_view()` so they survive bot restarts.
- **Ephemeral thread IDs** — Scheduled tasks (daily report, debrief) use date-based thread IDs like `daily_report_2025-06-15` so they don't accumulate conversation history across days.

## File Conventions

- Knowledge files live in `data/` as markdown (one file per topic, e.g. `garlic.md`)
- Special files: `tasks.md` (todo list with `- [ ]`/`- [x]` checkboxes), `harvests.md` (markdown table), `garden_log.md` (timestamped log entries), `planting_calendar.md` (auto-generated), `almanac.md`, `farm_layout.md`, `categories.md` (auto-generated by `!consolidate`), `members.json` (member registry, auto-created by `!register`)
- Daily briefing snapshots: `data/daily_YYYY-MM-DD.md`
- Consolidation backups: `data/backups/<filename>.<timestamp>.bak`
- SQLite conversation DB: `data/conversations.db`

## Commands

- `!briefing` — Manual trigger for the morning briefing (reminders or journal channel). Shows "Nothing urgent today — all clear!" when there's nothing to report. When members are registered, groups tasks by assignee and injects @mentions.
- `!debrief` — Manual trigger for the evening debrief prompt (journal channel only). Shows calling user's assigned tasks + unassigned tasks (if registered), or all open tasks otherwise.
- `!consolidate <topic>` — Find all files related to a topic, back them up, merge/deduplicate into a single clean file, and delete merged sub-files (questions, reminders, or journal channel)
- `!consolidate tasks` — LLM-powered task deduplication: analyzes open tasks for duplicates/near-duplicates, presents groups interactively with Merge/Keep All/Remove Duplicates buttons, then rewrites `tasks.md` based on user decisions. Backs up before modifying. Works in questions, reminders, or journal channel.
- `!consolidate` (no args) — LLM-based semantic categorization: sends all filenames to Gemini in batches, groups them by plant type (Trees, Herbs, Vegetables, etc.), identifies merge candidates, saves results to `categories.md`, and posts a summary to Discord. Falls back to prefix-based grouping on LLM failure.
- `!tasks` — Show all open tasks grouped by assignee with clean formatting (due dates, no metadata). Works in any monitored channel.
- `!calendar` — Show the current planting calendar as-is. Reads and displays `planting_calendar.md` directly. Works in any channel.
- `!recap [days]` — Generate a recap of the last N days (default 7, max 90) of garden activity. Summarizes journal entries, harvests, and task progress. Works in reminders, journal, or questions channel.
- `!setup` — Start onboarding flow. Redirects to DMs if called from a channel. Walks user through location/zone, garden layout, knowledge building, and channel orientation. Skips if already complete.
- `!register <name>` — Register the calling user as a named garden member. Creates/updates `data/members.json`.
- `!register <name> @user` — Register a mentioned user as a named member (admin use).
- `!members` — List all registered garden members with Discord @mentions.
- `!clear <topic>` — Delete a single knowledge file with 2-step confirmation (questions, reminders, or journal channel).
- `!clear knowledge` — Delete all non-system knowledge files with 3-step confirmation. System files (tasks, harvests, almanac, etc.) are preserved.
- `!clear garden` — Factory reset: deletes everything in `data/` (all files, conversations.db, members.json, backups/, .alert_flag) with 3-step confirmation.
- `!commands` — Show a help message listing all commands with brief usage.
- `!version` — Show the current Beanbot version (parsed from `pyproject.toml` at import time).

## Scheduled Tasks

- **8:00 AM** — `daily_report`: morning briefing with current weather, 48-hour forecast, tasks, planting calendar → reminders channel. Includes frost/rain-based watering and protection advice. When members are registered, tasks are grouped by assignee and names are replaced with @mentions.
- **8:00 PM** — `daily_debrief`: evening debrief prompt with all open tasks + button → journal channel
- **Every 6 hours** — `weather_alerts`: checks 48-hour forecast for frost (≤ 2°C) or significant rain (≥ 60% chance or ≥ 10mm). Posts alert to reminders channel, max once per day (deduped via `data/.alert_flag`).
- **Sunday 8:00 PM** — `weekly_recap`: automatic 7-day garden recap → reminders channel

## Environment Variables

Required in `.env` (or Docker environment):
- `DISCORD_TOKEN`, `REMINDERS_CHANNEL_ID`, `JOURNAL_CHANNEL_ID`, `QUESTIONS_CHANNEL_ID`, `KNOWLEDGE_INGEST_CHANNEL_ID`
- `GOOGLE_API_KEY`, `GEMINI_MODEL`
- `OPENWEATHER_API_KEY`, `WEATHER_LAT`, `WEATHER_LON`
- `BOT_TIMEZONE` (optional, default: `America/Denver`)
- `LLM_TIMEOUT` (optional, default: `60`) — seconds before LLM calls time out

## Development

**IMPORTANT: Always use `uv run` to run Python tools and scripts in this project.** Do not use bare `python`, `python3`, or `pip` — this project uses `uv` for dependency management and all commands should go through it.

```bash
# Run locally (needs .env)
uv run python -m src.bot

# Run with Docker
docker-compose up --build -d

# View logs
docker-compose logs -f

# Bump version (creates commit + tag)
# IMPORTANT: bump-my-version requires a clean working tree.
# Always stage and commit uv.lock (and any other modified files) BEFORE running this.
uv run bump-my-version bump patch|minor|major
```

## Commit, Tag & Push Procedure

When the user asks to commit, tag, and push (or any combination), follow this exact sequence every time:

1. `git add <files>` — stage your changes
2. `git commit` — commit with a descriptive message
3. `git add uv.lock` — uv.lock almost always has changes after installs/syncs. Stage it.
4. `git diff --cached --quiet uv.lock` — if uv.lock had changes, commit it: `git commit -m "Sync uv.lock"`
5. `uv run bump-my-version bump patch` (or minor/major as requested) — this requires a **clean working tree**. If it fails, check `git status`, commit any remaining dirty files, and retry.
6. `git push && git push --tags` — push everything including the new version tag.

Do NOT skip step 3. Do NOT try to run bump-my-version before ensuring a clean working tree. Do NOT debug this interactively — just follow the steps.

## Adding New Tools

1. Write the pure function in `src/services/tools.py`
2. Create a `@tool`-decorated wrapper in `src/graph.py`
3. Add it to the `TOOLS` list in `src/graph.py`
4. Mention it in `STATIC_SYSTEM_PROMPT` so the agent knows when to use it

## Things to Watch Out For

- `tool_overwrite_file` replaces entire file contents — the agent uses this for tasks.md updates (checking boxes). If the agent hallucinates content, the file gets corrupted. The system prompt warns it to use caution.
- The `trim_messages_for_context` function in `graph.py` keeps only the last 10 conversation turns to prevent context window overflow.
- All file operations in `tools.py` use `os.path.basename()` to prevent directory traversal.
- `SYSTEM_FILES` is defined once at the top of `tools.py` and used by `tool_delete_file` (prevents deletion), `_list_md_paths` (excludes from search/calendar/library listings), and `generate_calendar_from_library` (skips during scan).
- `!consolidate` always backs up files before modifying/deleting. Backups live in `data/backups/`.
- `!consolidate tasks` is a special keyword that bypasses knowledge-file consolidation and instead runs `analyze_duplicate_tasks()` from `categorization.py`. `TaskConsolidateView` in `bot.py` is non-persistent (no `custom_id`), author-gated, 5-min timeout. It steps through groups one at a time, editing the message in-place. `_apply_decisions()` backs up `tasks.md` before rewriting and preserves completed tasks through the rewrite.
- `categorize_files()` and `suggest_merges()` in `src/services/categorization.py` are direct LLM calls (no agent/tools) using `ChatGoogleGenerativeAI` without `.bind_tools()`. They batch files in groups of ~200 to avoid output token limits.
- `fetch_current_weather()` and `fetch_forecast()` in `src/services/weather.py` are standalone async functions with explicit parameters. Weather threshold constants (`FROST_THRESHOLD_C`, `RAIN_PROB_THRESHOLD_PCT`, `RAIN_MM_THRESHOLD`) are defined there.
- `_sanitize_topic()` and `_list_md_paths()` in `tools.py` are shared helpers used by multiple tool functions to avoid duplication.
- `bot.py` constants: `DISCORD_MESSAGE_LIMIT` (2000) and `INGESTION_CHUNK_SIZE` (50,000) control text chunking via `_chunk_text()`. Both `_send_long_reply()` and `run_recap_logic()` delegate to `_chunk_text()`.
- The system prompt maps "categories" questions to `categories.md` to prevent Gemini from hallucinating file lists from memory.
- **Onboarding detection**: `is_onboarding_complete()` in `tools.py` checks if `data/almanac.md` exists. When incomplete, DMs route through the `"onboarding"` channel context instead of `"dm"`. The `!setup` command initiates onboarding, redirecting to DMs if called from a channel.
- **Member registry & task assignment**: `data/members.json` stores `{lowercase_name: discord_id}` mappings. `register_member()` / `list_members()` / `get_member_name_by_discord_id()` in `tools.py` manage it. Tasks can have an `[Assigned: Name]` tag between description and `[Due:]`. `get_tasks_for_user(name)` returns tasks assigned to that user + unassigned tasks, excluding tasks assigned to others. `_inject_mentions()` in `bot.py` replaces registered names with `<@id>` Discord mentions in daily briefing output only. The `[User: Name]` prefix is injected into message content in `on_message` for registered users so the LLM knows who's asking. `members.json` is `.json`, not `.md`, so it's already ignored by `_list_md_paths` and `delete_knowledge_file`.
- **Version**: `_read_version()` in `bot.py` parses version from `pyproject.toml` at import time, cached as `BOT_VERSION`. Use `uv run bump-my-version bump patch|minor|major` to release (updates `pyproject.toml` + `CHANGELOG.md`, creates commit + tag). **`bump-my-version` requires a clean git working tree** — always commit `uv.lock` and any other dirty files before bumping.
- **`!clear` reserved words**: `garden` and `knowledge` are reserved arguments for `!clear` — they trigger bulk/factory-reset flows instead of deleting a file named `garden.md` or `knowledge.md`. Single-file deletion uses `_sanitize_topic()` and checks `SYSTEM_FILES` to prevent deleting protected files.
- **`!clear` confirmations**: `ConfirmView` is non-persistent (no `custom_id`, not registered in `setup_hook`). Each confirmation step edits the original message in-place. `interaction_check()` gates buttons to the initiating user. Timeout is 120 seconds per step.
- **Source citations**: `amend_topic_knowledge()` accepts an optional `source` parameter. Sources are classified by `_classify_source()` (URL domain → extension/government/organization/web, PDF filenames, Discord messages, images) and appended to a `## Sources` section at the bottom of each topic file, deduplicated. `_split_sources_section()` splits body from sources and is used by both `amend_topic_knowledge` (read-modify-write) and `generate_calendar_from_library` (strip sources before parsing). The tool wrapper in `graph.py` passes `source` through, and the system prompt instructs the LLM to always provide it during ingestion.
- **Conflict flagging**: Prompt-driven — the system prompt and knowledge_ingest context instruct the LLM to read existing topic files before amending and flag genuine contradictions using `> **Conflict:** Previous entry says X, but this source says Y.` blockquote format. Conflict notes are preserved through `!consolidate` merges for manual review.
- **Task duplicate detection**: `add_task()` performs word-overlap duplicate detection (Jaccard similarity >= 0.5) against existing open tasks before adding. Strips metadata (`[Assigned:]`, `[Due:]`, `(Created:)`, checkbox) and stop words before comparing. Returns similar tasks instead of adding if matches found. Pass `skip_duplicate_check=True` to bypass. The LLM is instructed to ask the user what to do when duplicates are found.
- **Task removal**: `tool_remove_tasks` permanently deletes open task lines matching a substring (unlike `tool_complete_task` which only checks the box). The system prompt instructs the LLM to use this for "remove"/"delete" requests and to never use `tool_overwrite_file` for task removal. The LLM is also instructed to never create placeholder "check care" tasks — it should use web search to find the info itself and create actionable tasks with concrete details.
- **Web search**: `tool_web_search` uses the `ddgs` package (lazy-imported) to search the web when the knowledge library lacks info. `max_results` is clamped 1–10 to prevent context flooding. The tool is synchronous (ToolNode runs it in a thread pool). The system prompt instructs the LLM to search the knowledge base first and only web-search when local files don't have the answer. DuckDuckGo may rate-limit under heavy use — the tool catches exceptions and returns an error string rather than crashing.
- **Docker non-root user**: The Dockerfile creates a `beanbot` user (UID 10000) and only grants write access to `data/`. Source code is root-owned and read-only. This prevents path traversal or code modification even if the LLM crafts a malicious path.
