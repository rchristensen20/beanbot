# CLAUDE.md

## Project Overview

Beanbot is a personal gardening assistant Discord bot. It uses a LangGraph agentic workflow backed by the Google Gemini API to manage a markdown-based knowledge library, task list, harvest log, and garden journal.

## Tech Stack

- **Python 3.13** with discord.py, LangGraph, langchain-google-genai, pymupdf
- **Google Gemini API** (Gemini 2.5 Flash) for LLM inference
- **LangGraph** state machine with tool-calling loop and SQLite checkpointer for conversation memory
- **Docker** for deployment (single container, `docker-compose up`)

## Architecture

```
src/bot.py                      ‚Üí Discord bot: message routing, commands, scheduled crons, UI components
src/graph.py                    ‚Üí LangGraph state machine: agent node ‚Üî tool node loop, system prompt, checkpointer
src/services/tools.py           ‚Üí Pure functions: file I/O, task management, harvest logging, calendar generation, member registry, web search
src/services/weather.py         ‚Üí Standalone async weather/forecast fetchers (OpenWeatherMap API)
src/services/categorization.py  ‚Üí LLM-based file categorization and merge suggestion (used by !consolidate)
data/                           ‚Üí Markdown knowledge library (auto-managed by the bot)
```

### Key patterns

- **Channel-based routing** ‚Äî `on_message` checks channel ID to determine context (journal, questions, knowledge_ingest, DM). Context strings are defined in the `CHANNEL_CONTEXT` dict at the top of `bot.py` and prepended to the HumanMessage, not stored as a separate SystemMessage.
- **PDF ingestion** ‚Äî PDF attachments in the knowledge_ingest channel are detected by content type or `.pdf` extension, text-extracted via `pymupdf`, and fed into the same ingestion pipeline as URL/text content. Scanned PDFs without a text layer will yield empty results (no OCR).
- **LLM processes everything** ‚Äî Rather than rigid parsing, structured user input (like debrief forms) is sent as a prompt to the LangGraph agent. The agent decides which tools to call.
- **Persistent Discord views** ‚Äî `discord.ui.View(timeout=None)` with `custom_id` on buttons, registered in `setup_hook` via `self.add_view()` so they survive bot restarts.
- **Ephemeral thread IDs** ‚Äî Scheduled tasks (daily report, debrief) use date-based thread IDs like `daily_report_2025-06-15` so they don't accumulate conversation history across days.

## File Conventions

- Knowledge files live in `data/` as markdown (one file per topic, e.g. `garlic.md`)
- Special files: `tasks.md` (todo list with `- [ ]`/`- [x]` checkboxes), `harvests.md` (markdown table), `garden_log.md` (timestamped log entries), `planting_calendar.md` (auto-generated), `almanac.md`, `farm_layout.md`, `categories.md` (auto-generated by `!consolidate`), `members.json` (member registry, auto-created by `!register`)
- Daily briefing snapshots: `data/daily_YYYY-MM-DD.md`
- Consolidation backups: `data/backups/<filename>.<timestamp>.bak`
- SQLite conversation DB: `data/conversations.db`

## Commands

- `!briefing` ‚Äî Manual trigger for the morning briefing (reminders or journal channel). Shows "Nothing urgent today ‚Äî all clear!" when there's nothing to report. When members are registered, groups tasks by assignee and injects @mentions.
- `!debrief` ‚Äî Manual trigger for the evening debrief prompt (journal channel only). Shows calling user's assigned tasks + unassigned tasks (if registered), or all open tasks otherwise.
- `!consolidate <topic>` ‚Äî Find all files related to a topic, back them up, merge/deduplicate into a single clean file, and delete merged sub-files (questions, reminders, or journal channel)
- `!consolidate tasks` ‚Äî LLM-powered task deduplication: analyzes open tasks for duplicates/near-duplicates, presents groups interactively with Merge/Keep All/Remove Duplicates buttons, then rewrites `tasks.md` based on user decisions. Backs up before modifying. Works in questions, reminders, or journal channel.
- `!consolidate` (no args) ‚Äî LLM-based semantic categorization: sends all filenames to Gemini in batches, groups them by plant type (Trees, Herbs, Vegetables, etc.), identifies merge candidates, saves results to `categories.md`, and posts a summary to Discord. Falls back to prefix-based grouping on LLM failure.
- `!tasks` ‚Äî Show all open tasks grouped by assignee with clean formatting (due dates, no metadata). Works in any monitored channel.
- `!calendar` ‚Äî Show the current planting calendar as-is. Reads and displays `planting_calendar.md` directly. Works in any channel.
- `!recap [days]` ‚Äî Generate a recap of the last N days (default 7, max 90) of garden activity. Summarizes journal entries, harvests, and task progress. Works in reminders, journal, or questions channel.
- `!setup` ‚Äî Start onboarding flow. Redirects to DMs if called from a channel. Walks user through location/zone, garden layout, knowledge building, and channel orientation. Skips if already complete.
- `!register <name>` ‚Äî Register the calling user as a named garden member. Creates/updates `data/members.json`.
- `!register <name> @user` ‚Äî Register a mentioned user as a named member (admin use).
- `!members` ‚Äî List all registered garden members with Discord @mentions.
- `!clear <topic>` ‚Äî Delete a single knowledge file with 2-step confirmation (questions, reminders, or journal channel).
- `!clear knowledge` ‚Äî Delete all non-system knowledge files with 3-step confirmation. System files (tasks, harvests, almanac, etc.) are preserved.
- `!clear garden` ‚Äî Factory reset: deletes everything in `data/` (all files, conversations.db, members.json, backups/, .alert_flag) with 3-step confirmation.
- `!commands` ‚Äî Show a help message listing all commands with brief usage.
- `!version` ‚Äî Show the current Beanbot version (parsed from `pyproject.toml` at import time).

## Scheduled Tasks

- **8:00 AM** ‚Äî `daily_report`: morning briefing with current weather, 48-hour forecast, tasks, planting calendar ‚Üí reminders channel. Includes frost/rain-based watering and protection advice. When members are registered, tasks are grouped by assignee and names are replaced with @mentions.
- **8:00 PM** ‚Äî `daily_debrief`: evening debrief prompt with all open tasks + button ‚Üí journal channel
- **Every 6 hours** ‚Äî `weather_alerts`: checks 48-hour forecast for frost (‚â§ 2¬∞C) or significant rain (‚â• 60% chance or ‚â• 10mm). Posts alert to reminders channel, max once per day (deduped via `data/.alert_flag`).
- **Sunday 8:00 PM** ‚Äî `weekly_recap`: automatic 7-day garden recap ‚Üí reminders channel

## Environment Variables

Required in `.env` (or Docker environment):
- `DISCORD_TOKEN`, `REMINDERS_CHANNEL_ID`, `JOURNAL_CHANNEL_ID`, `QUESTIONS_CHANNEL_ID`, `KNOWLEDGE_INGEST_CHANNEL_ID`
- `GOOGLE_API_KEY`, `GEMINI_MODEL`
- `OPENWEATHER_API_KEY`, `WEATHER_LAT`, `WEATHER_LON`
- `BOT_TIMEZONE` (optional, default: `America/Denver`)
- `LLM_TIMEOUT` (optional, default: `60`) ‚Äî seconds before LLM calls time out
- `GRAPH_RECURSION_LIMIT` (optional, default: `40`) ‚Äî max LangGraph agent‚Üîtool loop iterations before stopping. 40 = 20 round-trips. Prevents runaway tool-call loops.

## Development

**IMPORTANT: Always use `uv run` to run Python tools and scripts in this project.** Do not use bare `python`, `python3`, or `pip` ‚Äî this project uses `uv` for dependency management and all commands should go through it.

```bash
# Run locally (needs .env)
uv run python -m src.bot

# Run with Docker
docker-compose up --build -d

# View logs
docker-compose logs -f

# Bump version (creates commit + tag)
# IMPORTANT: bump-my-version requires a clean working tree.
# Always stage and commit uv.lock (and any other modified files) BEFORE running this.
uv run bump-my-version bump patch|minor|major
```

## Commit, Tag & Push Procedure

When the user asks to commit, tag, and push (or any combination), follow this exact sequence every time. Run steps 1-4 as a single chained command:

```bash
git add <files> && git commit -m "<message>" && uv sync --extra dev && git add uv.lock && git diff --cached --quiet || git commit -m "Sync uv.lock" && uv run bump-my-version bump patch && git push && git push --tags
```

Why `uv sync --extra dev`: `bump-my-version` is a dev dependency. Plain `uv sync` uninstalls dev extras, which removes bump-my-version. The `--extra dev` flag keeps it installed. This also syncs `uv.lock` with any pyproject.toml changes (e.g. from a previous version bump), ensuring a clean working tree before bump-my-version runs.

## Adding New Tools

1. Write the pure function in `src/services/tools.py`
2. Create a `@tool`-decorated wrapper in `src/graph.py`
3. Add it to the `TOOLS` list in `src/graph.py`
4. Mention it in `STATIC_SYSTEM_PROMPT` so the agent knows when to use it

## Things to Watch Out For

- `tool_overwrite_file` replaces entire file contents ‚Äî the agent uses this for tasks.md updates (checking boxes). If the agent hallucinates content, the file gets corrupted. The system prompt warns it to use caution.
- The `trim_messages_for_context` function in `graph.py` keeps only the last 4 conversation turns (configurable via `MAX_CONTEXT_TURNS` env var) to prevent context window overflow. Old messages are evicted from the checkpointed state via `RemoveMessage` so the SQLite DB doesn't grow unboundedly.
- All file operations in `tools.py` use `os.path.basename()` to prevent directory traversal.
- `SYSTEM_FILES` is defined once at the top of `tools.py` and used by `tool_delete_file` (prevents deletion), `_list_md_paths` (excludes from search/calendar/library listings), and `generate_calendar_from_library` (skips during scan).
- `!consolidate` always backs up files before modifying/deleting. Backups live in `data/backups/`.
- `!consolidate tasks` is a special keyword that bypasses knowledge-file consolidation and instead runs `analyze_duplicate_tasks()` from `categorization.py`. `TaskConsolidateView` in `bot.py` is non-persistent (no `custom_id`), author-gated, 5-min timeout. It steps through groups one at a time, editing the message in-place. `_apply_decisions()` backs up `tasks.md` before rewriting and preserves completed tasks through the rewrite.
- `categorize_files()` and `suggest_merges()` in `src/services/categorization.py` are direct LLM calls (no agent/tools) using `ChatGoogleGenerativeAI` without `.bind_tools()`. They batch files in groups of ~200 to avoid output token limits.
- `fetch_current_weather()` and `fetch_forecast()` in `src/services/weather.py` are standalone async functions with explicit parameters. Weather threshold constants (`FROST_THRESHOLD_C`, `RAIN_PROB_THRESHOLD_PCT`, `RAIN_MM_THRESHOLD`) are defined there.
- `_sanitize_topic()` and `_list_md_paths()` in `tools.py` are shared helpers used by multiple tool functions to avoid duplication.
- `bot.py` constants: `DISCORD_MESSAGE_LIMIT` (2000) and `INGESTION_CHUNK_SIZE` (50,000) control text chunking via `_chunk_text()`. Both `_send_long_reply()` and `run_recap_logic()` delegate to `_chunk_text()`.
- The system prompt maps "categories" questions to `categories.md` to prevent Gemini from hallucinating file lists from memory.
- **Onboarding detection**: `is_onboarding_complete()` in `tools.py` checks if `data/almanac.md` exists. When incomplete, DMs route through the `"onboarding"` channel context instead of `"dm"`. The `!setup` command initiates onboarding, redirecting to DMs if called from a channel.
- **Member registry & task assignment**: `data/members.json` stores `{lowercase_name: discord_id}` mappings. `register_member()` / `list_members()` / `get_member_name_by_discord_id()` in `tools.py` manage it. Tasks can have an `[Assigned: Name]` tag between description and `[Due:]`. `get_tasks_for_user(name)` returns tasks assigned to that user + unassigned tasks, excluding tasks assigned to others. `_inject_mentions()` in `bot.py` replaces registered names with `<@id>` Discord mentions in daily briefing output only. The `[User: Name]` prefix is injected into message content in `on_message` for registered users so the LLM knows who's asking. `members.json` is `.json`, not `.md`, so it's already ignored by `_list_md_paths` and `delete_knowledge_file`.
- **Version**: `_read_version()` in `bot.py` parses version from `pyproject.toml` at import time, cached as `BOT_VERSION`. Use `uv run bump-my-version bump patch|minor|major` to release (updates `pyproject.toml` + `CHANGELOG.md`, creates commit + tag). **`bump-my-version` requires a clean git working tree** ‚Äî always commit `uv.lock` and any other dirty files before bumping.
- **`!clear` reserved words**: `garden` and `knowledge` are reserved arguments for `!clear` ‚Äî they trigger bulk/factory-reset flows instead of deleting a file named `garden.md` or `knowledge.md`. Single-file deletion uses `_sanitize_topic()` and checks `SYSTEM_FILES` to prevent deleting protected files.
- **`!clear` confirmations**: `ConfirmView` is non-persistent (no `custom_id`, not registered in `setup_hook`). Each confirmation step edits the original message in-place. `interaction_check()` gates buttons to the initiating user. Timeout is 120 seconds per step.
- **Source citations**: `amend_topic_knowledge()` accepts an optional `source` parameter. Sources are classified by `_classify_source()` (URL domain ‚Üí extension/government/organization/web, PDF filenames, Discord messages, images) and appended to a `## Sources` section at the bottom of each topic file, deduplicated. `_split_sources_section()` splits body from sources and is used by both `amend_topic_knowledge` (read-modify-write) and `generate_calendar_from_library` (strip sources before parsing). The tool wrapper in `graph.py` passes `source` through, and the system prompt instructs the LLM to always provide it during ingestion.
- **Conflict flagging**: Prompt-driven ‚Äî the system prompt and knowledge_ingest context instruct the LLM to read existing topic files before amending and flag genuine contradictions using `> **Conflict:** Previous entry says X, but this source says Y.` blockquote format. Conflict notes are preserved through `!consolidate` merges for manual review.
- **Task duplicate detection**: `add_task()` performs word-overlap duplicate detection (Jaccard similarity >= 0.5) against existing open tasks before adding. Strips metadata (`[Assigned:]`, `[Due:]`, `(Created:)`, checkbox) and stop words before comparing. Returns similar tasks instead of adding if matches found. Pass `skip_duplicate_check=True` to bypass. The LLM is instructed to ask the user what to do when duplicates are found.
- **Task removal**: `tool_remove_tasks` permanently deletes open task lines matching a substring (unlike `tool_complete_task` which only checks the box). The system prompt instructs the LLM to use this for "remove"/"delete" requests and to never use `tool_overwrite_file` for task removal. The LLM is also instructed to never create placeholder "check care" tasks ‚Äî it should use web search to find the info itself and create actionable tasks with concrete details.
- **Task reassignment**: `tool_reassign_tasks(from_name, to_name)` bulk-reassigns all open tasks in a single read-write pass. Supports `from_name="unassigned"` to assign all unassigned tasks. The system prompt's efficiency rule directs the LLM to use this instead of repeatedly reading/rewriting tasks.md.
- **Graph recursion limit**: `GRAPH_RECURSION_LIMIT` (default 40, env-overridable) caps agent‚Üîtool loop iterations via LangGraph's `recursion_limit` config key. Applied at all 3 graph invocation sites in `bot.py`. Prevents runaway tool-call loops (e.g. 160+ calls for a simple reassignment). 40 iterations = 20 round-trips, generous for legitimate use.
- **Web search**: `tool_web_search` uses the `ddgs` package (lazy-imported) to search the web when the knowledge library lacks info. `max_results` is clamped 1‚Äì10 to prevent context flooding. The tool is synchronous (ToolNode runs it in a thread pool). The system prompt instructs the LLM to search the knowledge base first and only web-search when local files don't have the answer. DuckDuckGo may rate-limit under heavy use ‚Äî the tool catches exceptions and returns an error string rather than crashing.
- **Recurring tasks**: Tasks can have a `[Recurring: pattern]` metadata tag (between `[Assigned:]` and `[Due:]`). Supported patterns: `daily`, `weekly`, `monthly`, `every N days`, `every N weeks`. Recurring tasks require a `[Due:]` date. When a recurring task is completed via `complete_task()`, the next occurrence is auto-created with `skip_duplicate_check=True`. The next due date uses `max(original_due, today) + interval` so overdue tasks always reschedule into the future. Monthly handles month-end clamping (Jan 31 ‚Üí Feb 28). `remove_tasks()` permanently deletes lines ‚Äî recurrence dies with the task (intentional). `_TASK_METADATA_RE` strips `[Recurring:]` before Jaccard comparison so the tag doesn't affect duplicate detection. `_extract_task_description()` in `bot.py` strips the tag and appends a üîÅ emoji for visual distinction. `analyze_duplicate_tasks()` in `categorization.py` is instructed to NOT group tasks with different recurrence patterns as duplicates.
- **Focused daily briefing**: `run_daily_report_logic()` pre-filters tasks using `filter_tasks_due_today_or_overdue()` and injects them directly into the prompt instead of telling the LLM to read tasks.md. This prevents the LLM from reading 50+ tasks and wasting tokens. The prompt still instructs the LLM to read garden_log.md, planting_calendar.md, and almanac.md for seasonal context.
- **Docker non-root user**: The Dockerfile creates a `beanbot` user (UID 10000) and only grants write access to `data/`. Source code is root-owned and read-only. This prevents path traversal or code modification even if the LLM crafts a malicious path.
